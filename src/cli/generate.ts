#!/usr/bin/env node

/**
 * Code Generation CLI Tool
 *
 * Generate database schemas, API routes, frontend components, tests, and documentation
 * from entity definitions with comprehensive error handling and logging
 */

import path from 'path'
import { fileURLToPath } from 'url'
import fs from 'fs'
import { Result, ok, err } from 'neverthrow'
import pluralize from 'pluralize'

// Import generator interfaces
import type { CustomGenerator } from '../generator-interfaces'

// Import utilities
import {
  DEFAULT_CONFIG,
  parseCliArgs,
  mergeConfig,
  validateConfig,
  generateFileHeader,
  addEslintDisable,
  loadConfigFile,
  loadGeneratorScript,
  loadArgFiles,
  type GeneratorConfig,
  type GeneratorArgs,
} from '../utils/config.js'
import { logger } from '../utils/logger.js'
import { GeneratorError, GeneratorErrorCode, fromError } from '../utils/errors.js'
import { readSchemaFile, type ParsedField } from '../utils/schema-parser.js'
import { ensureDirectory, writeFile } from '../utils/file-system.js'
import { zodToCode } from '../utils/zod-codegen.js'

// Import field mappings (similar to old implementation)
import {
  resolveFieldConfig,
  excludeFromForms,
  type FieldMapping,
} from '../field-mappings.config.js'

/**
 * Get generator configuration
 */
function getConfig(): Result<GeneratorConfig, GeneratorError> {
  try {
    const cliArgs = parseCliArgs(process.argv.slice(2))
    const config = mergeConfig(DEFAULT_CONFIG, cliArgs)

    const validationResult = validateConfig(config)
    if (validationResult.isErr()) {
      return err(validationResult.error)
    }

    return ok(config)
  } catch (error) {
    return err(
      new GeneratorError(
        GeneratorErrorCode.INVALID_CONFIG,
        `Failed to parse configuration: ${error instanceof Error ? error.message : 'Unknown error'}`,
        undefined,
        error instanceof Error ? error : undefined
      )
    )
  }
}

/**
 * Generate Zod schema code from field configuration
 */
function generateZodSchemaCode(field: ParsedField, config: GeneratorConfig): Result<string, GeneratorError> {
  return zodToCode(field, {
    includeErrorMessages: config.codegen.includeErrorMessages,
    useStandardSchema: config.codegen.useStandardSchema,
  })
}

/**
 * Generate database schemas for all entities
 */
async function generateDatabase(args: GeneratorArgs): Promise<Result<void, GeneratorError>> {
  try {
    const { config, entities, customGenerators } = args
    logger.section('üóÑÔ∏è  Generating Database Schemas')

    // Ensure output directories exist
    const dbDirResult = ensureDirectory(config.paths.database)
    if (dbDirResult.isErr()) return err(dbDirResult.error)

    for (const entity of entities) {
      logger.subsection(`Processing ${entity.name.singular}`)

      // Use custom generator if available, otherwise use built-in
      let generated: any
      if (customGenerators?.generateDatabase) {
        // Custom generator should handle the full generation process
        await customGenerators.generateDatabase(args)
        continue // Skip built-in generation
      } else {
        // Use built-in generators for each database type
        generated = {
          drizzle: '', // Will be generated by custom generators
          prisma: '',
          sql: '',
          convex: '',
          migrations: [],
          relationships: [],
          indexes: [],
          constraints: []
        }
      }

      // Write Drizzle schema
      if (config.targets.includes('drizzle')) {
        const drizzlePath = path.join(config.paths.database, 'drizzle', `${entity.db.table.name}.ts`)
        const writeResult = writeFile(drizzlePath, generated.drizzle, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
        if (writeResult.isErr()) {
          logger.error(`Failed to write Drizzle schema for ${entity.name.singular}`, writeResult.error.code, {
            filePath: drizzlePath,
            error: writeResult.error.message
          })
          continue
        }
        logger.success(`Generated Drizzle schema: ${entity.db.table.name}.ts`)
      }

      // Write Prisma schema
      if (config.targets.includes('prisma')) {
        const prismaPath = path.join(config.paths.database, 'prisma', `${entity.db.table.name}.prisma`)
        const writeResult = writeFile(prismaPath, generated.prisma, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
        if (writeResult.isErr()) {
          logger.error(`Failed to write Prisma schema for ${entity.name.singular}`, writeResult.error.code, {
            filePath: prismaPath,
            error: writeResult.error.message
          })
          continue
        }
        logger.success(`Generated Prisma schema: ${entity.db.table.name}.prisma`)
      }

      // Write SQL migrations
      if (config.targets.includes('sql')) {
        const sqlPath = path.join(config.paths.database, 'migrations', `${entity.version}_${entity.db.table.name}.sql`)
        const writeResult = writeFile(sqlPath, generated.sql, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
        if (writeResult.isErr()) {
          logger.error(`Failed to write SQL migration for ${entity.name.singular}`, writeResult.error.code, {
            filePath: sqlPath,
            error: writeResult.error.message
          })
          continue
        }
        logger.success(`Generated SQL migration: ${entity.version}_${entity.db.table.name}.sql`)
      }

      // Write Convex schema
      if (config.targets.includes('convex')) {
        const convexPath = path.join(config.paths.database, 'convex', `${entity.db.table.name}.ts`)
        const writeResult = writeFile(convexPath, generated.convex, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
        if (writeResult.isErr()) {
          logger.error(`Failed to write Convex schema for ${entity.name.singular}`, writeResult.error.code, {
            filePath: convexPath,
            error: writeResult.error.message
          })
          continue
        }
        logger.success(`Generated Convex schema: ${entity.db.table.name}.ts`)
      }

      logger.incrementTables()
    }

    return ok(undefined)
  } catch (error) {
    return err(fromError(error, GeneratorErrorCode.CODE_GENERATION_ERROR))
  }
}

/**
 * Generate API code for all entities
 */
async function generateAPI(args: GeneratorArgs): Promise<Result<void, GeneratorError>> {
  try {
    const { config, entities, customGenerators } = args
    logger.section('üöÄ Generating API Code')

    // Use custom generator if available
    if (customGenerators?.generateAPI) {
      await customGenerators.generateAPI(args)
      return ok(undefined)
    }

    // Ensure output directories exist
    const routesDirResult = ensureDirectory(path.join(config.paths.api, 'routes'))
    if (routesDirResult.isErr()) return err(routesDirResult.error)

    const controllersDirResult = ensureDirectory(path.join(config.paths.api, 'controllers'))
    if (controllersDirResult.isErr()) return err(controllersDirResult.error)

    const middlewareDirResult = ensureDirectory(path.join(config.paths.api, 'middleware'))
    if (middlewareDirResult.isErr()) return err(middlewareDirResult.error)

    for (const entity of entities) {
      logger.subsection(`Processing ${entity.name.singular}`)

      const generated = APIGenerator.generate(entity, {
        framework: config.api.framework as any,
        includeValidation: config.api.includeValidation,
        includePermissions: config.api.includePermissions,
        includeOpenAPI: config.api.includeOpenAPI,
        includeTypes: config.api.includeTypes,
        basePath: config.api.basePath
      })

      // Write routes
      const routesPath = path.join(config.paths.api, 'routes', `${entity.name.plural}.ts`)
      const routesWriteResult = writeFile(routesPath, generated.routes, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
      if (routesWriteResult.isErr()) {
        logger.error(`Failed to write routes for ${entity.name.singular}`, routesWriteResult.error.code, {
          filePath: routesPath,
          error: routesWriteResult.error.message
        })
        continue
      }
      logger.success(`Generated routes: ${entity.name.plural}.ts`)

      // Write controllers
      const controllersPath = path.join(config.paths.api, 'controllers', `${entity.name.plural}.controller.ts`)
      const controllersWriteResult = writeFile(controllersPath, generated.controllers, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
      if (controllersWriteResult.isErr()) {
        logger.error(`Failed to write controllers for ${entity.name.singular}`, controllersWriteResult.error.code, {
          filePath: controllersPath,
          error: controllersWriteResult.error.message
        })
        continue
      }
      logger.success(`Generated controllers: ${entity.name.plural}.controller.ts`)

      // Write middleware
      const middlewarePath = path.join(config.paths.api, 'middleware', `${entity.name.plural}.middleware.ts`)
      const middlewareWriteResult = writeFile(middlewarePath, generated.middleware, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
      if (middlewareWriteResult.isErr()) {
        logger.error(`Failed to write middleware for ${entity.name.singular}`, middlewareWriteResult.error.code, {
          filePath: middlewarePath,
          error: middlewareWriteResult.error.message
        })
        continue
      }
      logger.success(`Generated middleware: ${entity.name.plural}.middleware.ts`)

      // Write validators
      if (generated.validators) {
        const validatorsPath = path.join(config.paths.api, 'validators', `${entity.name.plural}.validator.ts`)
        const validatorsWriteResult = writeFile(validatorsPath, generated.validators, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
        if (validatorsWriteResult.isErr()) {
          logger.error(`Failed to write validators for ${entity.name.singular}`, validatorsWriteResult.error.code, {
            filePath: validatorsPath,
            error: validatorsWriteResult.error.message
          })
          continue
        }
        logger.success(`Generated validators: ${entity.name.plural}.validator.ts`)
      }

      // Write types
      if (generated.types) {
        const typesPath = path.join(config.paths.api, 'types', `${entity.name.plural}.types.ts`)
        const typesWriteResult = writeFile(typesPath, generated.types, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
        if (typesWriteResult.isErr()) {
          logger.error(`Failed to write types for ${entity.name.singular}`, typesWriteResult.error.code, {
            filePath: typesPath,
            error: typesWriteResult.error.message
          })
          continue
        }
        logger.success(`Generated types: ${entity.name.plural}.types.ts`)
      }

      logger.incrementTables()
    }

    return ok(undefined)
  } catch (error) {
    return err(fromError(error, GeneratorErrorCode.CODE_GENERATION_ERROR))
  }
}

/**
 * Generate frontend code for all entities
 */
async function generateFrontend(args: GeneratorArgs): Promise<Result<void, GeneratorError>> {
  try {
    const { config, entities, customGenerators } = args
    logger.section('üé® Generating Frontend Code')

    // Use custom generator if available
    if (customGenerators?.generateFrontend) {
      await customGenerators.generateFrontend(args)
      return ok(undefined)
    }

    // Ensure output directories exist
    const componentsDirResult = ensureDirectory(config.paths.frontend)
    if (componentsDirResult.isErr()) return err(componentsDirResult.error)

    for (const entity of entities) {
      logger.subsection(`Processing ${entity.name.singular}`)

      const generated = FrontendGenerator.generate(entity)

      // Write components
      if (config.frontend.includeComponents) {
        Object.entries(generated.routes).forEach(([routeName, componentCode]) => {
          const componentPath = path.join(config.paths.frontend, 'components', `${routeName}${entity.name.singular}.tsx`)
          const writeResult = writeFile(componentPath, componentCode, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
          if (writeResult.isErr()) {
            logger.error(`Failed to write component ${routeName}${entity.name.singular}`, writeResult.error.code, {
              filePath: componentPath,
              error: writeResult.error.message
            })
            return
          }
          logger.success(`Generated component: ${routeName}${entity.name.singular}.tsx`)
        })
      }

      // Write forms
      if (config.frontend.includeForms) {
        Object.entries(generated.forms).forEach(([formName, formCode]) => {
          const formPath = path.join(config.paths.frontend, 'forms', `${formName}${entity.name.singular}Form.tsx`)
          const writeResult = writeFile(formPath, formCode, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
          if (writeResult.isErr()) {
            logger.error(`Failed to write form ${formName}${entity.name.singular}Form`, writeResult.error.code, {
              filePath: formPath,
              error: writeResult.error.message
            })
            return
          }
          logger.success(`Generated form: ${formName}${entity.name.singular}Form.tsx`)
        })
      }

      logger.incrementTables()
    }

    return ok(undefined)
  } catch (error) {
    return err(fromError(error, GeneratorErrorCode.CODE_GENERATION_ERROR))
  }
}

/**
 * Generate tests for all entities
 */
async function generateTests(args: GeneratorArgs): Promise<Result<void, GeneratorError>> {
  try {
    const { config, entities, customGenerators } = args
    logger.section('üß™ Generating Tests')

    // Use custom generator if available
    if (customGenerators?.generateTests) {
      await customGenerators.generateTests(args)
      return ok(undefined)
    }

    // Ensure output directories exist
    const testsDirResult = ensureDirectory(config.paths.tests)
    if (testsDirResult.isErr()) return err(testsDirResult.error)

    for (const entity of entities) {
      logger.subsection(`Processing ${entity.name.singular}`)

      const generated = TestGenerator.generate(entity, {
        framework: config.tests.framework as any,
        includeUnitTests: config.tests.includeUnitTests,
        includeIntegrationTests: config.tests.includeIntegrationTests,
        includeE2ETests: config.tests.includeE2ETests,
        includePermissionTests: config.tests.includePermissionTests,
        testDataFactory: config.tests.testDataFactory,
        mockExternalDeps: config.tests.mockExternalDeps
      })

      // Write unit tests
      if (generated.unit.length > 0) {
        const unitPath = path.join(config.paths.tests, 'unit', `${entity.name.plural}.unit.test.ts`)
        const unitWriteResult = writeFile(unitPath, generated.unit[0], { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
        if (unitWriteResult.isErr()) {
          logger.error(`Failed to write unit tests for ${entity.name.singular}`, unitWriteResult.error.code, {
            filePath: unitPath,
            error: unitWriteResult.error.message
          })
          continue
        }
        logger.success(`Generated unit tests: ${entity.name.plural}.unit.test.ts`)
      }

      // Write integration tests
      if (generated.integration.length > 0) {
        const integrationPath = path.join(config.paths.tests, 'integration', `${entity.name.plural}.integration.test.ts`)
        const integrationWriteResult = writeFile(integrationPath, generated.integration[0], { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
        if (integrationWriteResult.isErr()) {
          logger.error(`Failed to write integration tests for ${entity.name.singular}`, integrationWriteResult.error.code, {
            filePath: integrationPath,
            error: integrationWriteResult.error.message
          })
          continue
        }
        logger.success(`Generated integration tests: ${entity.name.plural}.integration.test.ts`)
      }

      // Write E2E tests
      if (generated.e2e.length > 0) {
        const e2ePath = path.join(config.paths.tests, 'e2e', `${entity.name.plural}.e2e.test.ts`)
        const e2eWriteResult = writeFile(e2ePath, generated.e2e[0], { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
        if (e2eWriteResult.isErr()) {
          logger.error(`Failed to write E2E tests for ${entity.name.singular}`, e2eWriteResult.error.code, {
            filePath: e2ePath,
            error: e2eWriteResult.error.message
          })
          continue
        }
        logger.success(`Generated E2E tests: ${entity.name.plural}.e2e.test.ts`)
      }

      // Write permission tests
      if (generated.permissions.length > 0) {
        const permissionsPath = path.join(config.paths.tests, 'permissions', `${entity.name.plural}.permissions.test.ts`)
        const permissionsWriteResult = writeFile(permissionsPath, generated.permissions[0], { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
        if (permissionsWriteResult.isErr()) {
          logger.error(`Failed to write permission tests for ${entity.name.singular}`, permissionsWriteResult.error.code, {
            filePath: permissionsPath,
            error: permissionsWriteResult.error.message
          })
          continue
        }
        logger.success(`Generated permission tests: ${entity.name.plural}.permissions.test.ts`)
      }

      logger.incrementTables()
    }

    return ok(undefined)
  } catch (error) {
    return err(fromError(error, GeneratorErrorCode.CODE_GENERATION_ERROR))
  }
}

/**
 * Generate documentation for all entities
 */
async function generateDocumentation(args: GeneratorArgs): Promise<Result<void, GeneratorError>> {
  try {
    const { config, entities, customGenerators } = args
    logger.section('üìö Generating Documentation')

    // Use custom generator if available
    if (customGenerators?.generateDocumentation) {
      await customGenerators.generateDocumentation(args)
      return ok(undefined)
    }

    // Ensure output directories exist
    const docsDirResult = ensureDirectory(config.paths.docs)
    if (docsDirResult.isErr()) return err(docsDirResult.error)

    for (const entity of entities) {
      logger.subsection(`Processing ${entity.name.singular}`)

      const generated = DocumentationGenerator.generate(entity)

      // Write markdown documentation
      const markdownPath = path.join(config.paths.docs, `${entity.name.plural}.md`)
      const markdownWriteResult = writeFile(markdownPath, generated.markdown, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
      if (markdownWriteResult.isErr()) {
        logger.error(`Failed to write markdown docs for ${entity.name.singular}`, markdownWriteResult.error.code, {
          filePath: markdownPath,
          error: markdownWriteResult.error.message
        })
        continue
      }
      logger.success(`Generated markdown docs: ${entity.name.plural}.md`)

      // Write OpenAPI spec
      const openapiPath = path.join(config.paths.docs, 'openapi', `${entity.name.plural}.openapi.json`)
      const openapiWriteResult = writeFile(openapiPath, generated.openapi, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
      if (openapiWriteResult.isErr()) {
        logger.error(`Failed to write OpenAPI spec for ${entity.name.singular}`, openapiWriteResult.error.code, {
          filePath: openapiPath,
          error: openapiWriteResult.error.message
        })
        continue
      }
      logger.success(`Generated OpenAPI spec: ${entity.name.plural}.openapi.json`)

      // Write permission matrix
      const permissionsPath = path.join(config.paths.docs, 'permissions', `${entity.name.plural}.permissions.md`)
      const permissionsWriteResult = writeFile(permissionsPath, generated.permissionMatrix, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
      if (permissionsWriteResult.isErr()) {
        logger.error(`Failed to write permission matrix for ${entity.name.singular}`, permissionsWriteResult.error.code, {
          filePath: permissionsPath,
          error: permissionsWriteResult.error.message
        })
        continue
      }
      logger.success(`Generated permission matrix: ${entity.name.plural}.permissions.md`)

      // Write ERD
      const erdPath = path.join(config.paths.docs, 'erd', `${entity.name.plural}.erd`)
      const erdWriteResult = writeFile(erdPath, generated.erd, { overwrite: config.overwrite, backup: config.createBackups, dryRun: config.dryRun })
      if (erdWriteResult.isErr()) {
        logger.error(`Failed to write ERD for ${entity.name.singular}`, erdWriteResult.error.code, {
          filePath: erdPath,
          error: erdWriteResult.error.message
        })
        continue
      }
      logger.success(`Generated ERD: ${entity.name.plural}.erd`)

      logger.incrementTables()
    }

    return ok(undefined)
  } catch (error) {
    return err(fromError(error, GeneratorErrorCode.CODE_GENERATION_ERROR))
  }
}

/**
 * Main function with comprehensive error handling
 */
async function main(): Promise<void> {
  try {
    logger.startGeneration()
    logger.section('üöÄ Code Generation CLI')

    // Get base configuration
    const baseConfigResult = getConfig()
    if (baseConfigResult.isErr()) {
      logger.error('Configuration error', baseConfigResult.error.code, {
        error: baseConfigResult.error.message
      })
      process.exit(1)
    }

    let config = baseConfigResult.value

    // Load custom config file if specified
    if (config.configFile) {
      logger.subsection(`Loading custom config: ${config.configFile}`)
      const customConfigResult = await loadConfigFile(config.configFile)
      if (customConfigResult.isErr()) {
        logger.error('Failed to load custom config', customConfigResult.error.code, {
          error: customConfigResult.error.message
        })
        process.exit(1)
      }
      config = mergeConfig(config, customConfigResult.value)
      logger.success(`Loaded custom config: ${config.configFile}`)
    }

    // Load custom generator script if specified
    let customGenerators: any = null
    if (config.generatorScript) {
      logger.subsection(`Loading custom generators: ${config.generatorScript}`)
      const generatorResult = await loadGeneratorScript(config.generatorScript)
      if (generatorResult.isErr()) {
        logger.error('Failed to load custom generators', generatorResult.error.code, {
          error: generatorResult.error.message
        })
        process.exit(1)
      }
      customGenerators = generatorResult.value
      logger.success(`Loaded custom generators: ${config.generatorScript}`)
    }

    // Load argument files if specified
    let loadedArgs: any[] = []
    if (config.argFiles && config.argFiles.length > 0) {
      logger.subsection(`Loading argument files: ${config.argFiles.join(', ')}`)
      const argsResult = await loadArgFiles(config.argFiles)
      if (argsResult.isErr()) {
        logger.error('Failed to load argument files', argsResult.error.code, {
          error: argsResult.error.message
        })
        process.exit(1)
      }
      loadedArgs = argsResult.value
      logger.success(`Loaded ${loadedArgs.length} argument files`)
    }

    logger.setLevel(config.logLevel)

    if (config.dryRun) {
      logger.info('üîç DRY RUN MODE - No files will be written')
    }

    // Read and parse schema
    logger.subsection('Reading Schema')
    const schemaContentResult = readSchemaFile(config.paths.schema)
    if (schemaContentResult.isErr()) {
      logger.error('Failed to read schema file', schemaContentResult.error.code, {
        filePath: config.paths.schema,
        error: schemaContentResult.error.message
      })
      process.exit(1)
    }

    // For now, we'll create mock entities - in real implementation, parse from schema
    const mockEntities = [
      {
        id: 'user',
        name: { singular: 'User', plural: 'Users' },
        version: 1,
        createdAt: new Date(),
        db: {
          table: { name: 'users', primaryKey: ['id'] },
          columns: {
            id: { type: { typeName: 'uuid', toDrizzle: () => 'uuid("id").primaryKey()' } },
            email: { type: { typeName: 'varchar', typeParams: [255], toDrizzle: () => 'varchar("email", { length: 255 })' } },
            name: { type: { typeName: 'varchar', typeParams: [100], toDrizzle: () => 'varchar("name", { length: 100 })' } }
          }
        },
        fields: {
          id: { jsType: 'string' },
          email: { jsType: 'string', standardSchema: {} as any },
          name: { jsType: 'string', standardSchema: {} as any }
        }
      }
    ]

    logger.success(`Parsed ${mockEntities.length} entities from schema`)

    // Create generator args object
    const generatorArgs: GeneratorArgs = {
      config,
      entities: mockEntities,
      argFiles: loadedArgs,
      customGenerators
    }

    // Generate code based on targets
    const generationPromises: Promise<Result<void, GeneratorError>>[] = []

    if (config.targets.includes('database')) {
      if (customGenerators?.generateDatabase) {
        generationPromises.push(customGenerators.generateDatabase(generatorArgs))
      } else {
        generationPromises.push(generateDatabase(generatorArgs))
      }
    }

    if (config.targets.includes('api')) {
      if (customGenerators?.generateAPI) {
        generationPromises.push(customGenerators.generateAPI(generatorArgs))
      } else {
        generationPromises.push(generateAPI(generatorArgs))
      }
    }

    if (config.targets.includes('frontend')) {
      if (customGenerators?.generateFrontend) {
        generationPromises.push(customGenerators.generateFrontend(generatorArgs))
      } else {
        generationPromises.push(generateFrontend(generatorArgs))
      }
    }

    if (config.targets.includes('tests')) {
      if (customGenerators?.generateTests) {
        generationPromises.push(customGenerators.generateTests(generatorArgs))
      } else {
        generationPromises.push(generateTests(generatorArgs))
      }
    }

    if (config.targets.includes('docs')) {
      if (customGenerators?.generateDocumentation) {
        generationPromises.push(customGenerators.generateDocumentation(generatorArgs))
      } else {
        generationPromises.push(generateDocumentation(generatorArgs))
      }
    }

    // Wait for all generations to complete
    const results = await Promise.all(generationPromises)

    // Check for errors
    const errors = results.filter(result => result.isErr())
    if (errors.length > 0) {
      errors.forEach(error => {
        logger.error('Generation failed', error.error.code, {
          error: error.error.message
        })
      })
      process.exit(1)
    }

    // Print report
    logger.endGeneration()
    logger.printReport()

    // Print usage information
    if (!config.dryRun && mockEntities.length > 0) {
      console.log('\nüìö Generated files:\n')

      if (config.targets.includes('database')) {
        console.log('Database schemas in:', config.paths.database)
      }
      if (config.targets.includes('api')) {
        console.log('API code in:', config.paths.api)
      }
      if (config.targets.includes('frontend')) {
        console.log('Frontend components in:', config.paths.frontend)
      }
      if (config.targets.includes('tests')) {
        console.log('Tests in:', config.paths.tests)
      }
      if (config.targets.includes('docs')) {
        console.log('Documentation in:', config.paths.docs)
      }
    }

  } catch (error) {
    const genError = fromError(error)
    logger.error('Unexpected error in main function', genError.code, {
      error: genError.message
    })
    process.exit(1)
  }
}

// Run the CLI
main().catch((error) => {
  console.error('üí• Fatal error:', error)
  process.exit(1)
})